#---- begin snakebids boilerplate ----------------------------------------------

from snakebids import bids, generate_inputs, get_wildcard_constraints
import nibabel as nib
import numpy as np

configfile: 'config/snakebids.yml'

# Get input wildcards
inputs = generate_inputs(
    bids_dir=config["bids_dir"],
    pybids_inputs=config["pybids_inputs"],
    pybidsdb_dir=config.get("pybidsdb_dir"),
    pybidsdb_reset=config.get("pybidsdb_reset"),
    derivatives=config.get("derivatives", None),
    participant_label=config.get("participant_label", None),
    exclude_participant_label=config.get("exclude_participant_label", None),
    validate=not config.get("plugins.validator.skip", False)
)

#this adds constraints to the bids naming
wildcard_constraints:  **get_wildcard_constraints(config['pybids_inputs'])

#---- end snakebids boilerplate ------------------------------------------------

#take union of affine and rigid
#affine_rigid_subjects = set(inputs['affine'].zip_lists['subject']) | set(inputs['rigid'].zip_lists['subject'])

#intersect with other sets of subjects
#subjects = affine_rigid_subjects & set(inputs['ct'].zip_lists['subject']) & set(inputs['landmarks_ct'].zip_lists['subject'])

rule all:
    input:
        electrode_mask = inputs['rigid'].expand(
            bids(
                root=config['output_dir'],
                desc='electrode',
                res='{res}',
                suffix='mask.nii.gz',
                **inputs['rigid'].wildcards),
                res=config['res_mm']
        ),
        contact_mask = inputs['rigid'].expand(
            bids(
                root=config['output_dir'],
                desc='contacts',
                res='{res}',
                suffix='mask.nii.gz',
                **inputs['rigid'].wildcards),
                res=config['res_mm']
        ),
        patches = inputs['rigid'].expand(
            bids(
                root=config['output_dir'],
                suffix='patches31.dat',
                res='{res}',
                **inputs['rigid'].wildcards),
                res=config['res_mm']
        ),
        patches_63 = inputs['rigid'].expand(
            bids(
                root=config['output_dir'],
                suffix='patches63.dat',
                res='{res}',
                **inputs['rigid'].wildcards),
                res=config['res_mm']
        )

        
        
rule resample:
    input:
        orig_ct =  inputs['ct'].path
    
    params:
        interpolation = 'Cubic',
        dims = '0.4x0.4x0.4mm'
    
    output:
        resampled_ct = bids(
            root=config['output_dir'],
            res='{res}',
            suffix='ct.nii.gz',
            **inputs['rigid'].wildcards
        )

    group: 'subj'
    
    container:
        config["singularity"]["diffparc"]

    shell: 'c3d {input.orig_ct} -interpolation {params.interpolation} -resample-mm {params.dims} -o {output.resampled_ct}'


# def get_rigid_or_affine(wildcards):
#     #have the subject id (wildcards.subject)
#     #want to pick either rigid or affine, depending on which zip list contains the subject
#     if wildcards.subject in inputs['affine'].zip_lists['subject']:
#         return inputs['affine'].path
#     elif wildcards.subject in inputs['rigid'].zip_lists['subject']:
#         return inputs['rigid'].path
#     else:
#         print('subject has neither affine or rigid!')
        

rule transform_points_ct:
    input: 
        orig_point = inputs['landmarks'].path,
        aff = inputs['rigid'].path
    
    output:
        transformed_txt = bids(
            root=config['output_dir'],
            space = 'native_ct',
            suffix='landmarks.txt',
            **inputs['rigid'].wildcards
        )
    
    group: 'subj'

    run:
        import numpy as np
        affine = np.loadtxt(input.aff)
        inv = np.linalg.inv(affine)
        points = np.loadtxt(input.orig_point).T
        transformed_points = np.dot(inv, points)
        np.savetxt(output.transformed_txt, transformed_points.T, fmt='%f')

rule create_contact_mask:
    input: 
        landmarks = rules.transform_points_ct.output.transformed_txt,
        resampled_ct = rules.resample.output.resampled_ct

    output:
        contact_mask = bids(
            root=config['output_dir'],
            desc='contacts',
            res='{res}',
            suffix='mask.nii.gz',
            **inputs['rigid'].wildcards
        )

    group: 'subj'
    
    container:
        config["singularity"]["diffparc"]
    
    shell: 'c3d {input.resampled_ct} -scale 0 -landmarks-to-spheres {input.landmarks} 1 -o {output.contact_mask}'

rule znormalize_ct:
    input:
        resampled_ct = rules.resample.output.resampled_ct,
    
    output:
        znorm_ct = bids(
            root = config["output_dir"],
            res='{res}',
            desc='z_norm',
            suffix='ct.nii.gz',
            **inputs['rigid'].wildcards
        )

    resources:    
        mem_mb = 10000

    group: 'subj'

    script: 
        './scripts/znormalize_ct.py'


rule create_electrode_mask:
    input: 
        znorm_ct = rules.resample.output.resampled_ct,  
        actual = inputs['actual'].path,
        transform_matrix = inputs['rigid'].path,

    output:
        electrode_mask = bids(
            root=config['output_dir'],
            desc='electrode',
            res='{res}',
            suffix='mask.nii.gz',
            **inputs['rigid'].wildcards
        )

    group: 'subj'

    resources:    
        mem_mb = 32000
    
    script: 
        './scripts/electrode_mask_creation.py'


# rule thresh_ct:
#     input: 
#         ct = rules.resample.output.resampled_ct,

#     output:
#         thresh = bids(
#             root=config['output_dir'],
#             desc='thresh_2500',
#             res='{res}',
#             suffix='ct.nii.gz',
#             **inputs['affine'].wildcards
#         )

#     group: 'subj'

#     resources:    
#         mem_mb = 32000

#     container:
#         config["singularity"]["diffparc"]
    
#     shell: 'c3d {input.ct} -threshold 2500 inf 1 0 {output.thresh}'


# rule create_patches:
#     input:
#         ct = rules.resample.output.resampled_ct,
#         contact_mask = rules.create_contact_mask.output.contact_mask,
#         electrode_mask = rules.create_electrode_mask.output.electrode_mask
#         #will update to binary brain mask
    
#     params:
#         radius_vector = '47x47x47', #patch dimensions will be (x*2)+1 voxels
#         n = '2', #sample n randomly augment patches
#         angle = '30', #stdev of normal distribution for sampling angle (in degrees)
#         frequency = '14000' #sample 1 patch for every n voxels

#     output:
#         patches = bids(
#             root=config['output_dir'],
#             suffix='patches95.dat',
#             res='{res}',
#             **inputs['rigid'].wildcards
#         )

#     resources:    
#         mem_mb = 32000
    
#     group: 'subj'

#     container:
#         config["singularity"]["diffparc"]

#     shell: 'c3d {input.ct} {input.contact_mask} {input.electrode_mask} -xpa {params.n} {params.angle} -xp {output.patches} {params.radius_vector} {params.frequency}'

rule create_patches_64:
    input:
        ct = rules.resample.output.resampled_ct,
        contact_mask = rules.create_contact_mask.output.contact_mask,
        electrode_mask = rules.create_electrode_mask.output.electrode_mask
        #will update to binary brain mask
    
    params:
        radius_vector = '31x31x31', #patch dimensions will be (x*2)+1 voxels
        n = '2', #sample n randomly augment patches
        angle = '30', #stdev of normal distribution for sampling angle (in degrees)
        frequency = '12000' #sample 1 patch for every n voxels

    output:
        patches = bids(
            root=config['output_dir'],
            suffix='patches63.dat',
            res='{res}',
            **inputs['rigid'].wildcards
        )

    resources:    
        mem_mb = 32000
    
    group: 'subj'

    container:
        config["singularity"]["diffparc"]

    shell: 'c3d {input.ct} {input.contact_mask} {input.electrode_mask} -xpa {params.n} {params.angle} -xp {output.patches} {params.radius_vector} {params.frequency}'

rule create_patches_32:
    input:
        ct = rules.resample.output.resampled_ct,
        contact_mask = rules.create_contact_mask.output.contact_mask,
        electrode_mask = rules.create_electrode_mask.output.electrode_mask
        #will update to binary brain mask
    
    params:
        radius_vector = '15x15x15', #patch dimensions will be (x*2)+1 voxels
        n = '2', #sample n randomly augment patches
        angle = '30', #stdev of normal distribution for sampling angle (in degrees)
        frequency = '10000' #sample 1 patch for every n voxels

    output:
        patches = bids(
            root=config['output_dir'],
            suffix='patches31.dat',
            res='{res}',
            **inputs['rigid'].wildcards
        )

    resources:    
        mem_mb = 32000
    
    group: 'subj'

    container:
        config["singularity"]["diffparc"]

    shell: 'c3d {input.ct} {input.contact_mask} {input.electrode_mask} -xpa {params.n} {params.angle} -xp {output.patches} {params.radius_vector} {params.frequency}'
